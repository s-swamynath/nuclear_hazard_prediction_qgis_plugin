# -*- coding: utf-8 -*-
"""
/***************************************************************************
 hazardPredictionDialog
                                 A QGIS plugin
 CBRN Hazard Area Prediction
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-20
        git sha              : $Format:%H$
        copyright            : (C) 2024 by 201 Engr Regt
        email                : admin@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtGui import QColor
from qgis.core import QgsVectorLayer, QgsProject, QgsLayerTreeGroup, QgsFillSymbol, QgsSingleSymbolRenderer

# 'iface' is a referenec to the QGIS Interface that allows user to interact with the QGIS Application and its
# components, such as layers, canvas and plugins.

from qgis.utils import iface
import geopandas as gpd
from shapely.geometry import Point, LineString, Polygon
from geopy.distance import distance
import math

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'hazardPrediction_dialog_base.ui'))


class hazardPredictionDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(hazardPredictionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Add button of addPointButton check if pressed
        self.addPointButton.clicked.connect(self.generateNHP)

    def generatePoint(self, ref_lat, ref_lon, dist, deg):

        # geopy distance function requires meters
        distance_meters  = dist * 1000

        # Calculate coordinates of the second point
        destination = distance(meters = distance_meters).destination((ref_lat,ref_lon), deg)

        return destination.longitude, destination.latitude


    def generateLine(self, ref_lat, ref_lon, dist, deg):

        new_point = self.generatePoint(ref_lat, ref_lon, dist, deg)

        line = LineString([(ref_lon, ref_lat), new_point])

        return line
    
    def generateTangent(self, ref_lat, ref_lon, zone_1_dist, wind_dir, cloud_radius):

        point_left_cloud = self.generatePoint(ref_lat, ref_lon, cloud_radius, wind_dir-90)
        point_left_zone = self.generatePoint(ref_lat, ref_lon, zone_1_dist, wind_dir-20)

        left_tangent_line = LineString([point_left_cloud, point_left_zone])

        point_right_cloud = self.generatePoint(ref_lat, ref_lon, cloud_radius, wind_dir+90)
        point_right_zone = self.generatePoint(ref_lat, ref_lon, zone_1_dist, wind_dir+20)

        right_tangent_line = LineString([point_right_cloud, point_right_zone])

        return left_tangent_line, right_tangent_line

    def generateArc(self, ref_lat, ref_lon, radius, from_deg, to_deg):

        # Number of points to approximate the circle
        # Adjust as needed for smoothness of the circel
        num_points = int(((to_deg - from_deg) / 10) + 1)

        # List to hold points of the circle
        arc_points = []

        # Calculate points around the circle
        for i in range(num_points):

            # Calculate coordinates of the point
            # Bearing in degrees (90 Degrees is east)
            bearing = from_deg + (i * 10)

            point = self.generatePoint(ref_lat, ref_lon, radius, bearing)

            arc_points.append(point)

        # Create a Shapely Polygon object from the circle_points
        arc = LineString(arc_points)    

        return arc
    
    def generateAtomicDamageTemplate(self, center_lat, center_lon, cloud_radius):
        
        # Enter Atomic Damage Template Data as Dictonary
        atomic_damage_template_dict = {
            0.8: [0.24, 0.435, 0.565, 0.74],
            1.0: [0.26, 0.465, 0.6, 0.795],
            5.0: [0.415, 0.752, 0.976, 1.29],
            10.0: [0.51, 0.93, 1.2, 1.585],
            15.0: [0.58, 1.045, 1.36, 1.79],
            20.0: [0.63, 1.14, 1.48, 1.98]
        }

        # Calculate the yield of nuclear blast given the cloud radius using Emperical Scaling Law
        yield_estimate = (cloud_radius/1.3) ** 3

        # Initialize closest higher yield as 20.0
        closest_higher_yield = 20.0

                # Find the closest higher yield value if the given yield is less than any key in the dictionary
        # Iterate through the keys of the dictionary
        for key in atomic_damage_template_dict:
            if key >= yield_estimate:
                closest_higher_yield = key
                break

        # Print Yield and closest higher yield
        print(yield_estimate," ", closest_higher_yield)

        # Get the corresponding distances from the template
        distances = atomic_damage_template_dict[closest_higher_yield]

        # Generate arcs for the distances
        arcs = []
        for dist in distances:
            arc = self.generateArc(center_lat, center_lon, dist, 0, 360)
            arcs.append(arc)

        return arcs

    def generateNHP(self):
        
        # Generate the Nuclear Hazard Prediction (NHP) geometry and save it as shapefile
        center_lat = float(self.latitudeInput.text())
        center_lon = float(self.longitudeInput.text())
        cloud_radius = float(self.cloudRadius.text())
        wind_direction = float(self.windDirection.text())
        zone_distance= float(self.zoneDistance.text())

        # Generate circle of ground zero
        cloud = self.generateArc(center_lat, center_lon,cloud_radius,0,360)

        # Generate Radial line
        left_radial_line = self.generateLine(center_lat, center_lon, 2*zone_distance, wind_direction - 20)
        right_radial_line = self.generateLine(center_lat, center_lon, 2*zone_distance, wind_direction + 20)

        # Zone arc
        zone_1_arc = self.generateArc(center_lat, center_lon, zone_distance, wind_direction - 20, wind_direction + 20)
        zone_2_arc = self.generateArc(center_lat, center_lon, 2 * zone_distance, wind_direction - 20, wind_direction + 20)

        # Tangent Line
        tangents = self.generateTangent(center_lat, center_lon, zone_distance, wind_direction, cloud_radius)

        # Atomic Damage Template
        atomic_damage_template = self.generateAtomicDamageTemplate(center_lat, center_lon, cloud_radius)

        # Combine all geometries into a list
        NHP_geometries = [cloud, left_radial_line, right_radial_line, zone_1_arc, zone_2_arc, tangents[0], tangents[1]]
        zone_1_geometries = [cloud, zone_1_arc, tangents[0], tangents[1]]
        zone_2_geometeries = [left_radial_line, right_radial_line, zone_2_arc]

        # Create  GeoDataFrame
        NHP_gdf = gpd.GeoDataFrame(geometry=NHP_geometries, crs = 'EPSG:4326')
        zone_1_gdf = gpd.GeoDataFrame(geometry=zone_1_geometries, crs='EPSG:4326')
        zone_2_gdf = gpd.GeoDataFrame(geometry=zone_2_geometeries, crs='EPSG:4326')

        # Generate the convex hull (outer boundary) which is a polygon object
        NHP_boundary = NHP_gdf.unary_union.convex_hull
        zone_1_boundary = zone_1_gdf.unary_union.convex_hull
        zone_2_boundary = zone_2_gdf.unary_union.convex_hull

        # Create of NHP Zones shape files with color coding
        NHP_Zones = [zone_1_boundary, zone_2_boundary]
        NHP_color_list = ["#FFCC00", "#FFFF00"]
        NHP_names_list = ["Zone I : > 150 Rads in 4 hrs", "Zone II : > 50 Rads in 24 hrs"]
        self.diffGeometry(NHP_Zones, NHP_color_list, NHP_names_list)

        # Create NHP Lines
        self.geometryToLayer(NHP_geometries, "NHP", "black", 255)
        
        # Create atomic damage template shape files with color coding
        atomic_damage_template_color_list = ["#FF0000", "#FF3300", "#FF6600", "#FF9900"]
        atomic_damage_template_names_list = ["Zone A : A Veh & Guns", "Zone B : B Veh & Protected Tps", "Zone C : Exposed Pers", "Zone D : Moderate Damage to Protected troops"]
        self.diffGeometry(atomic_damage_template, atomic_damage_template_color_list, atomic_damage_template_names_list)

        # Create Atomic Damage Template Lines
        self.geometryToLayer(atomic_damage_template,  "Atomic", "black", 255)      

        # Create a GeoDataFrame for the outer boundary
        NHP_boundary_gdf = gpd.GeoDataFrame(geometry=[NHP_boundary], crs = 'EPSG:4326')

        # Define output shapefile path
        NHP_boundary_shapefile_path = "NHP_boundary.shp"

        # Save Geodataframe to shapefile
        NHP_boundary_gdf.to_file(NHP_boundary_shapefile_path)    

        self.checkPoints(center_lat, center_lon)

    def diffGeometry(self, geometry_list, color_list, name_list):
        geometry_list_temp = []
        for idx, geometries in enumerate(geometry_list):

            # Create GeoDataFrame
            gdf_temp = gpd.GeoDataFrame(geometry=[geometries], crs='EPSG:4326')

            # Generate the convex hull (outer boundary) which is a polygon object
            geometry_boundary_temp = gdf_temp.unary_union.convex_hull
            geometry_list_temp.append(geometry_boundary_temp)

            # Create several boundary after removing intersection
            if(idx != 0):
                geometry_boundary_temp = geometry_boundary_temp.difference(geometry_list_temp[idx-1])

            self.geometryToLayer([geometry_boundary_temp], name_list[idx], color_list[idx], 125)

    def geometryToLayer(self, geometries, name, color, transperacy):

        # Create a geoDataFrame for the outer boundary
        boundary_gdf_temp = gpd.GeoDataFrame(geometry=geometries, crs = 'EPSG:4326')

        # Define Output shapefile path
        shapefile_path_temp = name+".shp"

        # Save GeoDataFrame to Shape file
        boundary_gdf_temp.to_file(shapefile_path_temp)

        # Add layer style
        self.addAndStyleLayer(shapefile_path_temp, color, transperacy)


    def addAndStyleLayer(self, shapefile_path, color, transparency):
        layer = QgsVectorLayer(shapefile_path, shapefile_path, 'ogr')

        QgsProject.instance().addMapLayer(layer)

        # Create a symbol with specified color and transparency
        symbol = QgsFillSymbol.defaultSymbol(layer.geometryType())
        rgba_color = QColor(color)
        rgba_color.setAlpha(transparency)
        symbol.setColor(rgba_color)

        # Create a renderer and apply the symbol
        renderer = QgsSingleSymbolRenderer(symbol)
        layer.setRenderer(renderer)
        layer.triggerRepaint()

        # Refresh layer symbology in QGIS layer tree view
        iface.layerTreeView().refreshLayerSymbology(layer.id())

    def checkPoints(self, ref_lat, ref_lon):
        # Load shapefiles and check if points are inside the boundary polygon
        points_path = "c:/Users/user/Documents/points.shp"
        boundary_path = "c:/Users/user/Documents/NHP_boundary.shp"

        # Load the shapefiles to geopandas dataframe
        points_gdf = gpd.read_file(points_path)
        boundary_gdf = gpd.read_file(boundary_path)

        # Assume the boundary shapefile contains only one polygon
        boundary_polygon = boundary_gdf.geometry.unary_union

        # Initialize lists to store results
        locations = []
        distances = []
        nearest_safepoints = []

        # Iterate through each point in points_gdf
        for point in points_gdf.geometry:

            # Calculate distance from reference point (ref_lat, ref_lon) to each point
            dist = distance((ref_lat, ref_lon), (point.y, point.x)).meters
            distances.append(int(dist))
            nearest_safepoints.append('Self')
         
            # Check if point is inside the boundary polygon
            if point.within(boundary_polygon):
                locations.append('inside')
            else:
                locations.append('outside')

        # Update GeoDataFrame with results
        points_gdf['NHP'] = locations
        points_gdf['dist'] = distances   

        # Find the nearest outside point for each inside point
        for idx, point in enumerate(points_gdf.geometry):

            if locations[idx] == 'inside':
                    
                # Float('inf') indicates float value of infinity, this is used to find min value.
                min_dist = float('inf')
                nearest_safepoint = 'Self'

                for outside_idx, (outside_point, name) in enumerate(zip(points_gdf.geometry, points_gdf['name'])):
                    if locations[outside_idx] == 'outside':
                        dist = point.distance(outside_point)
                        if dist < min_dist:
                            min_dist = dist
                            nearest_safepoint = name

                nearest_safepoints[idx] = nearest_safepoint
        
        # Update GeoDataFrame with results
        points_gdf['safe_loc'] = nearest_safepoints

        # Save the updated points from geopandas dataframe to the same shapefile
        points_gdf.to_file(points_path, driver = 'ESRI Shapefile')

        # Refresh QGIS layers
        iface.addVectorLayer(points_path, '', 'ogr')